# .github/workflows/sync-and-patch.yml
name: Sync with Upstream and Patch

on:
  schedule:
    # 周一 02:13 北京 (周日 18:13 UTC)
    - cron: '13 18 * * 0'
    # 周三 02:27 北京 (周二 18:27 UTC)
    - cron: '27 18 * * 2'
    # 周五 02:42 北京 (周四 18:42 UTC)
    - cron: '42 18 * * 4'
  # 允许手动触发
  workflow_dispatch:

# 授予工作流写入代码和触发其他工作流的权限
permissions:
  contents: write
  actions: write

jobs:
  sync_and_build:
    runs-on: ubuntu-latest
    steps:
      # 步骤 0: 检出你的仓库，使用 PAT 以获得推送权限
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # 使用你创建的 PAT，它有权限修改工作流文件
          token: ${{ secrets.FFMPEG_UPDATE_TOKEN }}
          # 确保我们获取所有历史记录，以便与上游进行比较
          fetch-depth: 0

      - name: Set up Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # 在重置之前，备份此工作流文件，因为它会被删除
      - name: Backup sync workflow file
        run: cp .github/workflows/sync-and-patch.yml /tmp/sync-and-patch.yml

      # 步骤 1: 将你的 master 分支与上游同步
      - name: Sync with upstream repository
        id: sync
        run: |
          # 添加上游仓库
          git remote add upstream https://github.com/BtbN/FFmpeg-Builds.git
          git fetch upstream --prune
          
          echo "Current local HEAD: $(git rev-parse HEAD)"
          echo "Current upstream HEAD: $(git rev-parse upstream/master)"

          # --- 正确的变更检测逻辑 ---
          # 我们不再简单比较本地和上游的 HEAD，因为我们的本地分支总会有一个额外的“补丁”提交。
          # 相反，我们找到本地 HEAD 和上游 HEAD 的“共同祖先”。
          # 如果上游 HEAD 和共同祖先是同一个提交，说明上游没有新的提交。
          # 如果它们不同，说明上游已经向前移动了，有了新的更新。
          
          MERGE_BASE=$(git merge-base HEAD upstream/master)
          UPSTREAM_HASH=$(git rev-parse upstream/master)

          echo "Common ancestor commit: $MERGE_BASE"

          if [ "$MERGE_BASE" == "$UPSTREAM_HASH" ]; then
            echo "Repository is up-to-date with upstream. No new commits found."
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "New commits detected on upstream repository."
            echo "changed=true" >> $GITHUB_OUTPUT
          fi
          
          # 无论是否有更新，都执行重置，以确保我们的补丁是基于最新的上游代码
          echo "Resetting local master to upstream/master..."
          git reset --hard upstream/master
          
      # 步骤 3 (恢复文件): 将之前备份的 sync-and-patch.yml 文件放回原位
      - name: Restore sync workflow file
        run: |
          mkdir -p .github/workflows
          cp /tmp/sync-and-patch.yml .github/workflows/sync-and-patch.yml

      - name: Install yq
        run: sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq && sudo chmod +x /usr/bin/yq

      # 步骤 2: 使用 yq 对 build.yml 应用补丁
      - name: Patch build.yml workflow
        run: |
          WORKFLOW_FILE=".github/workflows/build.yml"
          
          echo "--- Applying patches to $WORKFLOW_FILE ---"
          
          # 1. 修改仓库名检查
          yq eval -i '(.jobs.pre_check.steps[] | select(.name == "Repo Check").run) |= sub("BtbN/FFmpeg-Builds", "${{ github.repository }}")' $WORKFLOW_FILE
          echo "Patched: Repository check"
          
          # 2. 移除 push 和 schedule 触发器，防止自动运行
          yq eval -i 'del(.on.push) | del(.on.schedule)' $WORKFLOW_FILE
          echo "Patched: Removed push and schedule triggers"

          # 3. 移除 runner 和 target 中的 arm 和 32位
          yq eval -i '.jobs.build_base.strategy.matrix.runner = ["ubuntu-latest"]' $WORKFLOW_FILE
          yq eval -i '.jobs.build_target_bases.strategy.matrix.target = ["win64", "linux64"]' $WORKFLOW_FILE
          yq eval -i '.jobs.build_targets.strategy.matrix.target = ["win64", "linux64"]' $WORKFLOW_FILE
          yq eval -i '.jobs.build_ffmpeg.strategy.matrix.target = ["win64", "linux64"]' $WORKFLOW_FILE
          echo "Patched: Removed arm/32bit targets and runners"

          # 4. 限制 variant
          yq eval -i '.jobs.build_targets.strategy.matrix.variant = ["nonfree", "nonfree-shared"]' $WORKFLOW_FILE
          yq eval -i '.jobs.build_ffmpeg.strategy.matrix.variant = ["nonfree", "nonfree-shared"]' $WORKFLOW_FILE
          echo "Patched: Limited variants to nonfree and nonfree-shared"

          echo "--- Patched $WORKFLOW_FILE content ---"
          cat $WORKFLOW_FILE
          
      - name: Commit and push changes
        run: |
          # 将所有更改（包括重置、补丁和恢复的文件）添加到暂存区
          git add .github/workflows/build.yml .github/workflows/sync-and-patch.yml
          
          # 检查是否有任何需要提交的更改
          if ! git diff --staged --quiet; then
            echo "Changes detected. Committing and pushing..."
            git commit -m "chore: Sync with upstream and apply patches [skip ci]"
            # 强制推送，因为我们重置了历史记录
            git push origin master --force
          else
            echo "No changes to commit."
          fi

      # 步骤 4: 如果上游有更新，则触发 build.yml
      - name: Trigger build workflow if upstream changed
        if: steps.sync.outputs.changed == 'true'
        env:
          # gh CLI 需要 GITHUB_TOKEN，我们使用 PAT 以确保权限足够
          GITHUB_TOKEN: ${{ secrets.FFMPEG_UPDATE_TOKEN }}
        run: |
          echo "Upstream changes were detected. Triggering the 'Build FFmpeg' workflow in ${{ github.repository }}."
          # 等待几秒钟，确保 Git 推送已在 GitHub 端完全处理
          sleep 15
          # 明确指定目标仓库为当前仓库
          gh workflow run build.yml --ref master --repo ${{ github.repository }}


